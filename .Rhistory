savehistory("~/.Rhistory")
library(ggmap)
df <- read.csv("~/Sanjiv.csv") ## directory + csv file with addresses
colnames(df)
#[1] "Location" "Address"  "City"     "State"    "Zip"
head(df)
unique(df$State) ## useful to run on columns like ZIP, State and City; not useful on Address
df$State <- "CA" ## Sanjiv.csv file has funky characters
## add a new column with the full address
df$`lookupAddress` <- paste(df$Address, df$City, df$State, df$Zip, sep = ", ") ## use back ticks around the new column name
print(df)
lookupAddress <- df$`lookupAddress`
## no longer in parallel. Just a function now.
myfun <- function(i){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
result <- ggmap::geocode(location = oneAddress, output = "latlona", override_limit = T)
output <- cbind(oneAddress, result)
return(output)
} else {
## if the Address is NA, then return a row of NAs
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
#output <- cbind(oneAddress, result)
return(output)
}
}
library(foreach)
library(doParallel)
cl <- makeCluster(4)
registerDoParallel(cl)
foreach(i=1:3) %dopar% sqrt(i) ## just a test
## apply the geocode in parallel using 4 cores
parallelResults <- foreach(i = 1:length(lookupAddress)) %dopar% {
myfun(i)
}
parallelResults
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = "off", source = "dsk", force = TRUE)
## no longer in parallel. Just a function now.
myfun <- function(i){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = "off", source = "dsk", force = TRUE)
output <- cbind(oneAddress, result)
return(output)
} else {
## if the Address is NA, then return a row of NAs
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
#output <- cbind(oneAddress, result)
return(output)
}
}
foreach(i=1:3) %dopar% sqrt(i) ## just a test
parallelResults <- foreach(i = 1:length(lookupAddress)) %dopar% {
myfun(i)
}
myfun <- function(i){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = FALSE, source = "dsk", force = TRUE)
output <- cbind(oneAddress, result)
return(output)
} else {
## if the Address is NA, then return a row of NAs
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
#output <- cbind(oneAddress, result)
return(output)
}
}
parallelResults <- foreach(i = 1:length(lookupAddress)) %dopar% {
myfun(i)
}
parallelOutput = do.call("rbind", parallelResults)
parallelOutput
rm(list=ls())
library(ggmap)
df <- read.csv("~/Sanjiv.csv") ## directory + csv file with addresses
colnames(df)
#For best results, please have the following columns "Location" "Address"  "City"     "State"    "Zip"
head(df)
unique(df$State) ## useful to run on columns like ZIP, State and City; not useful on Address
df$State <- "CA" ## Sanjiv.csv file has funky characters
## add a new column with the full address
df$`lookupAddress` <- paste(df$Address, df$City, df$State, df$Zip, sep = ", ") ## use back ticks around the new column name
print(df)
lookupAddress <- df$`lookupAddress`
lookupAddress <- rbind(df$`lookupAddress`, "", "gibberish")
lookupAddress
df$`lookupAddress` <- paste(df$Address, df$City, df$State, df$Zip, sep = ", ") ## use back ticks around the new column name
lookupAddress <- rbind(df$`lookupAddress`, c("", "gibberish"))
lookupAddress <- rbind(df$`lookupAddress`, "gibberish")
lookupAddress
lookupAddress <- df$`lookupAddress`
lookupAddress
lookupAddress[50] <- "gibberish"
lookupAddress[51] <- ""
lookupAddress
## no longer in parallel. Just a function now.
myfun <- function(i, source = "google"){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
## source = "google" works only if not running in parallel!
## if using in parallel, use source = "dsk"
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = FALSE, source = source, force = TRUE)
output <- cbind(oneAddress, result)
return(output)
} else {
## if the Address is NA, then return a row of NAs
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
return(output)
}
}
Results = lapply(X=1:length(lookupAddress), FUN=myfun) ##  if you only want the top 10 records geocoded, change this to X=1:10
output = do.call("rbind", Results)
Results
## no longer in parallel. Just a function now.
myfun <- function(i, source = "google"){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
## source = "google" works only if not running in parallel!
## if using in parallel, use source = "dsk"
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = FALSE, source = source, force = TRUE)
output <- cbind(oneAddress, result)
return(output)
} else {
## if the Address is NA, then return a row of NAs
result <- data.frame(lon = NA, lat = NA, address = NA)
output <- cbind(oneAddress, result)
return(output)
}
}
Results = lapply(X=40:length(lookupAddress), FUN=myfun) ##  if you only want the top 10 records geocoded, change this to X=1:10
Results
rm(Results)
Results = lapply(X=40:length(lookupAddress), FUN=myfun) ##  if you only want the top 10 records geocoded, change this to X=1:10
Results
?geocode
dim(Results[[11]])
length(Results[[11]])
## no longer in parallel. Just a function now.
myfun <- function(i, source = "google"){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
## source = "google" works only if not running in parallel!
## if using in parallel, use source = "dsk"
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = FALSE, source = source)
output <- cbind(oneAddress, result)
} else {
## if the Address is NA, then return a row of NAs
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
}
if(length(output) != 4){
## if the result of the geocode query doesn't look right, return NA
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
}
return(output)
}
Results = lapply(X=40:length(lookupAddress), FUN=myfun) ##  if you only want the top 10 records geocoded, change this to X=1:10
output = do.call("rbind", Results)
Results
## apply the geocode in parallel using 4 cores
parallelResults <- foreach(i = 1:length(lookupAddress)) %dopar% {
myfun(i, source = "dsk")
}
library(foreach)
library(doParallel)
cl <- makeCluster(4)
registerDoParallel(cl)
foreach(i=1:3) %dopar% sqrt(i) ## just a test
## apply the geocode in parallel using 4 cores
parallelResults <- foreach(i = 1:length(lookupAddress)) %dopar% {
myfun(i, source = "dsk")
}
parallelResults
parallelOutput = do.call("rbind", parallelResults)
print(parallelResults)
print(parallelOutput)
library(readr)
library(dplyr)
library(ggplot2)
setwd(dir = "~/Desktop/Google Drive/SDSU/DA-Exam-2017/")
list.files(getwd())
df <- read_csv(file = "df.csv")
mtcars$gear <- factor(mtcars$gear,levels=c(3,4,5),
labels=c("3gears","4gears","5gears"))
mtcars$am <- factor(mtcars$am,levels=c(0,1),
labels=c("Automatic","Manual"))
mtcars$cyl <- factor(mtcars$cyl,levels=c(4,6,8),
labels=c("4cyl","6cyl","8cyl"))
# Kernel density plots for mpg
# grouped by number of gears (indicated by color)
qplot(mpg, data=mtcars, geom="density", fill=gear, alpha=I(.5),
main="Distribution of Gas Milage", xlab="Miles Per Gallon",
ylab="Density")
glimpse(df)
unique(df$`Number of cylinders`)
df$`Number of cylinders` == "."
sum(df$`Number of cylinders` == ".")
df[57,]
df[57, "Number of cylinders"] <- NA
unique(df$`Number of cylinders`)
sapply(c("3","4","5","6","8"), function(x) paste(x, sep = " cylinders"))
sapply(c("3","4","5","6","8"), function(x) cat(x, " cylinders"))
sapply(c("3","4","5","6","8"), function(x) paste(x, " cylinders"))
sapply(c("3","4","5","6","8"), function(x) paste(x, "cylinders"))
df$`Number of cylinders` <- factor(df$`Number of cylinders`, levels=c("3","4","5","6","8"),
labels=sapply(c("3","4","5","6","8"), function(x) paste(x, "cylinders")))
glimpse(df)
df$`Type` <- as.factor(df$Type)
df$`Air Bags standard` <- factor(df$`Air Bags standard`, levels=c(0, 1, 2),
labels=c("None","Driver only","Driver & passenger"))
qplot(`Number of cylinders`, data=df, geom="density", fill=`Number of cylinders`, alpha=I(.5),
main="Distribution of Gas Milage", xlab="Miles Per Gallon",
ylab="Density")
df %>% group_by(`Number of cylinders`) %>% summarise(count = n())
glimpse(df)
qplot(`City MPG`, data=df, geom="density", fill=`Number of cylinders`, alpha=I(.5),
main="Distribution of Gas Milage", xlab="Miles Per Gallon",
ylab="Density")
qplot(`Highway MPG`, data=df, geom="density", fill=`Number of cylinders`, alpha=I(.5),
main="Distribution of Gas Milage", xlab="Miles Per Gallon",
ylab="Density")
?qplot
qplot(``, data=df, geom="bar", fill=`Number of cylinders`, alpha=I(.5),
main="Distribution of Gas Milage", xlab="Miles Per Gallon",
ylab="Density")
qplot(`Number of cylinders`, data=df, geom="bar", fill=`Number of cylinders`, alpha=I(.5),
main="Distribution of Gas Milage", xlab="Miles Per Gallon",
ylab="Density")
qplot(`Number of cylinders`, data=df, geom="bar", fill=`Number of cylinders`, alpha=I(.5),
main="Distribution of Cylinders", xlab="Number of Cylinders",
ylab="Count")
