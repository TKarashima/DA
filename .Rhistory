savehistory("~/.Rhistory")
library(ggmap)
df <- read.csv("~/Sanjiv.csv") ## directory + csv file with addresses
colnames(df)
#[1] "Location" "Address"  "City"     "State"    "Zip"
head(df)
unique(df$State) ## useful to run on columns like ZIP, State and City; not useful on Address
df$State <- "CA" ## Sanjiv.csv file has funky characters
## add a new column with the full address
df$`lookupAddress` <- paste(df$Address, df$City, df$State, df$Zip, sep = ", ") ## use back ticks around the new column name
print(df)
lookupAddress <- df$`lookupAddress`
## no longer in parallel. Just a function now.
myfun <- function(i){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
result <- ggmap::geocode(location = oneAddress, output = "latlona", override_limit = T)
output <- cbind(oneAddress, result)
return(output)
} else {
## if the Address is NA, then return a row of NAs
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
#output <- cbind(oneAddress, result)
return(output)
}
}
library(foreach)
library(doParallel)
cl <- makeCluster(4)
registerDoParallel(cl)
foreach(i=1:3) %dopar% sqrt(i) ## just a test
## apply the geocode in parallel using 4 cores
parallelResults <- foreach(i = 1:length(lookupAddress)) %dopar% {
myfun(i)
}
parallelResults
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = "off", source = "dsk", force = TRUE)
## no longer in parallel. Just a function now.
myfun <- function(i){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = "off", source = "dsk", force = TRUE)
output <- cbind(oneAddress, result)
return(output)
} else {
## if the Address is NA, then return a row of NAs
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
#output <- cbind(oneAddress, result)
return(output)
}
}
foreach(i=1:3) %dopar% sqrt(i) ## just a test
parallelResults <- foreach(i = 1:length(lookupAddress)) %dopar% {
myfun(i)
}
myfun <- function(i){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = FALSE, source = "dsk", force = TRUE)
output <- cbind(oneAddress, result)
return(output)
} else {
## if the Address is NA, then return a row of NAs
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
#output <- cbind(oneAddress, result)
return(output)
}
}
parallelResults <- foreach(i = 1:length(lookupAddress)) %dopar% {
myfun(i)
}
parallelOutput = do.call("rbind", parallelResults)
parallelOutput
rm(list=ls())
library(ggmap)
df <- read.csv("~/Sanjiv.csv") ## directory + csv file with addresses
colnames(df)
#For best results, please have the following columns "Location" "Address"  "City"     "State"    "Zip"
head(df)
unique(df$State) ## useful to run on columns like ZIP, State and City; not useful on Address
df$State <- "CA" ## Sanjiv.csv file has funky characters
## add a new column with the full address
df$`lookupAddress` <- paste(df$Address, df$City, df$State, df$Zip, sep = ", ") ## use back ticks around the new column name
print(df)
lookupAddress <- df$`lookupAddress`
lookupAddress <- rbind(df$`lookupAddress`, "", "gibberish")
lookupAddress
df$`lookupAddress` <- paste(df$Address, df$City, df$State, df$Zip, sep = ", ") ## use back ticks around the new column name
lookupAddress <- rbind(df$`lookupAddress`, c("", "gibberish"))
lookupAddress <- rbind(df$`lookupAddress`, "gibberish")
lookupAddress
lookupAddress <- df$`lookupAddress`
lookupAddress
lookupAddress[50] <- "gibberish"
lookupAddress[51] <- ""
lookupAddress
## no longer in parallel. Just a function now.
myfun <- function(i, source = "google"){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
## source = "google" works only if not running in parallel!
## if using in parallel, use source = "dsk"
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = FALSE, source = source, force = TRUE)
output <- cbind(oneAddress, result)
return(output)
} else {
## if the Address is NA, then return a row of NAs
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
return(output)
}
}
Results = lapply(X=1:length(lookupAddress), FUN=myfun) ##  if you only want the top 10 records geocoded, change this to X=1:10
output = do.call("rbind", Results)
Results
## no longer in parallel. Just a function now.
myfun <- function(i, source = "google"){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
## source = "google" works only if not running in parallel!
## if using in parallel, use source = "dsk"
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = FALSE, source = source, force = TRUE)
output <- cbind(oneAddress, result)
return(output)
} else {
## if the Address is NA, then return a row of NAs
result <- data.frame(lon = NA, lat = NA, address = NA)
output <- cbind(oneAddress, result)
return(output)
}
}
Results = lapply(X=40:length(lookupAddress), FUN=myfun) ##  if you only want the top 10 records geocoded, change this to X=1:10
Results
rm(Results)
Results = lapply(X=40:length(lookupAddress), FUN=myfun) ##  if you only want the top 10 records geocoded, change this to X=1:10
Results
?geocode
dim(Results[[11]])
length(Results[[11]])
## no longer in parallel. Just a function now.
myfun <- function(i, source = "google"){
## print progress
if(i %% 10 == 0){
print("Progress: ")
p <- round(100 * i/length(lookupAddress), 2)
print(paste(p, "% Complete", sep = ""))
}
oneAddress <- lookupAddress[i] ## may need a comma such as, [i,]
if(!is.na(oneAddress)){
print(oneAddress)
## source = "google" works only if not running in parallel!
## if using in parallel, use source = "dsk"
result <- ggmap::geocode(location = oneAddress, output = "latlona", messaging = FALSE, source = source)
output <- cbind(oneAddress, result)
} else {
## if the Address is NA, then return a row of NAs
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
}
if(length(output) != 4){
## if the result of the geocode query doesn't look right, return NA
output <- data.frame(oneAddress = oneAddress, lon = NA, lat = NA, address = NA)
}
return(output)
}
Results = lapply(X=40:length(lookupAddress), FUN=myfun) ##  if you only want the top 10 records geocoded, change this to X=1:10
output = do.call("rbind", Results)
Results
## apply the geocode in parallel using 4 cores
parallelResults <- foreach(i = 1:length(lookupAddress)) %dopar% {
myfun(i, source = "dsk")
}
library(foreach)
library(doParallel)
cl <- makeCluster(4)
registerDoParallel(cl)
foreach(i=1:3) %dopar% sqrt(i) ## just a test
## apply the geocode in parallel using 4 cores
parallelResults <- foreach(i = 1:length(lookupAddress)) %dopar% {
myfun(i, source = "dsk")
}
parallelResults
parallelOutput = do.call("rbind", parallelResults)
print(parallelResults)
print(parallelOutput)
qplot(x = `Manufacturer`, y = `Midrange Price`, data=df, geom=c("boxplot", "jitter"),
fill=`Manufacturer`, main="Midrange Price by Manufacturer",
xlab="Manufacturer", ylab="Midrange Price")
setwd(dir = "~/Desktop/Google Drive/SDSU/DA-Exam-2017/")
list.files(getwd())
# ggplot2 examples
library(readr)
library(dplyr)
options(dplyr.width = Inf)
library(ggplot2)
df <- read_csv(file = "df.csv")
glimpse(df)
## interesting fact: 1995 Mazda RX-7 doesn't have a conventional piston engine; It has two rotational things that act like a 6-cylinder engine.
sum(df$`Number of cylinders` == ".")
df[57, "Number of cylinders"] <- NA
## Chevy Corvette and Mazda RX-7 have NA for Rear seat room; no rear seats
df$`Rear seat room` <- as.numeric(df$`Rear seat room`)
df[is.na(df$`Rear seat room`),]
# create factors with value labels
df$`Number of cylinders` <- factor(df$`Number of cylinders`, levels=c("3","4","5","6","8"),
labels=sapply(c("3","4","5","6","8"), function(x) paste(x, "cylinders")))
df$`Drive train type` <- factor(df$`Drive train type`, levels=c(0, 1, 2),
labels=c("rear wheel drive", "front wheel drive", "all wheel drive"))
df$`Manual transmission available` <- factor(df$`Manual transmission available`, levels=c(0, 1),
labels=c("No", "Yes"))
df$`Type` <- as.factor(df$Type)
df$`Air Bags standard` <- factor(df$`Air Bags standard`, levels=c(0, 1, 2),
labels=c("None","Driver only","Driver & passenger"))
df$Domestic <- factor(df$Domestic, levels = c(0, 1),
labels = c("non-US", "US"))
# grouped by number of gears (indicated by color)
df %>% group_by(`Number of cylinders`) %>% summarise(count = n())
qplot(x = `Domestic`, y = `Midrange Price`, data=df, geom="boxplot",
fill=`Manufacturer`, main="Midrange Price by Manufacturer",
xlab="Manufacturer", ylab="Midrange Price")
qplot(x = `Domestic`, y = `Midrange Price`, data=df, geom="boxplot",
fill=`Domestic`, main="Midrange Price by Manufacturer",
xlab="Manufacturer", ylab="Midrange Price")
qplot(x = `Domestic`, y = `Midrange Price`, data=df, geom="boxplot",
fill=`Manufacturer`, main="Midrange Price by Manufacturer",
xlab="Domestic & Manufacturer", ylab="Midrange Price")
glimpse(df)
df$Manufacturer <- as.factor(df$Manufacturer)
df <- df[, !(colnames(df) %in% c("Model", "Maximum Price", "Minimum Price"))]
glimpse(df)
df <- read_csv(file = "df.csv")
glimpse(df)
## interesting fact: 1995 Mazda RX-7 doesn't have a conventional piston engine; It has two rotational things that act like a 6-cylinder engine.
sum(df$`Number of cylinders` == ".")
df[57, "Number of cylinders"] <- NA
## Chevy Corvette and Mazda RX-7 have NA for Rear seat room; no rear seats
df$`Rear seat room` <- as.numeric(df$`Rear seat room`)
df[is.na(df$`Rear seat room`),]
# create factors with value labels
df$Manufacturer <- as.factor(df$Manufacturer)
df$`Number of cylinders` <- factor(df$`Number of cylinders`, levels=c("3","4","5","6","8"),
labels=sapply(c("3","4","5","6","8"), function(x) paste(x, "cylinders")))
df$`Drive train type` <- factor(df$`Drive train type`, levels=c(0, 1, 2),
labels=c("rear wheel drive", "front wheel drive", "all wheel drive"))
df$`Manual transmission available` <- factor(df$`Manual transmission available`, levels=c(0, 1),
labels=c("No", "Yes"))
df$`Type` <- as.factor(df$Type)
df$`Air Bags standard` <- factor(df$`Air Bags standard`, levels=c(0, 1, 2),
labels=c("None","Driver only","Driver & passenger"))
df$Domestic <- factor(df$Domestic, levels = c(0, 1),
labels = c("non-US", "US"))
df2 <- df[, !(colnames(df) %in% c("Model", "Maximum Price", "Minimum Price"))]
glimpse(df2)
linfit <- lm(formula = `City MPG` ~ ., data = df2)
summary(lmfit)
summary(linfit)
linfit <- lm(formula = `Midrange Price` ~ ., data = df2)
summary(linfit)
anova(linfit)
stepfit <- step(object = linfit)
df2 <- na.omit(df2)
glimpse(df2)
linfit <- lm(formula = `Midrange Price` ~ ., data = df2)
summary(linfit)
anova(linfit)
stepfit <- step(object = linfit)
summary(stepfit)
anova(stepfit, linfit)
anova(linfit, stepfit)
anova(stepfit, linfit)
